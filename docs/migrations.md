Database migrations in this project are handled as a separate and controlled process rather than being bundled into the main deployment pipeline. This approach was chosen because schema changes are sensitive operations and should not run automatically with every application deployment. Running migrations independently reduces the risk of accidental data loss or unintended structural changes in production environments.

All database migration scripts are stored as SQL files inside a dedicated migrations directory. These SQL files are written to be idempotent, meaning they can be executed multiple times without causing failures or duplicate changes. For example, table creation scripts use conditional logic to create tables only if they do not already exist, and column changes are applied only when the column is missing. This ensures safe execution across environments and supports reruns without manual intervention.

A lightweight Python runner is used to execute the migration scripts. When the migration task runs, it connects to the MySQL database using credentials securely injected at runtime and sequentially executes all SQL files explained in the migrations directory. The execution is wrapped inside a transaction, so if any migration fails, all changes are rolled back to maintain database consistency. Successful execution commits the transaction only after all scripts complete without errors.

Migrations are executed by running a one-time ECS task instead of running directly from GitHub Actions or from the application containers. This design ensures that database access happens from within the same private network as the RDS instance, preserving network isolation and security. The migration container is deployed using ECS RunTask, runs the migration logic once, and then exits. No long-running service is created for migrations.

The migration workflow is triggered manually through GitHub Actions. This allows operators to decide exactly when a schema change should be applied, typically before deploying a new application version that depends on that change. To apply new migrations, the user simply adds new SQL files to the migrations directory and triggers the migration workflow. The system automatically picks up and applies the new scripts without requiring any code changes.

These migrations are handled by writing sql quires and placing them in migration/sql directory , which will be used by py script to run them over the database. Finally you need to write the mysql quires to .sql files , to maintain the numeric consistancy to execute in order used numbers in the file names.